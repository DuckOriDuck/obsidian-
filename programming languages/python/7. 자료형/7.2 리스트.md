# 리스트
```python
x = [1, 2, 3] #CSV 파일과 비슷 ,
y = ['apple', 'banana', 'cherry']
z = [2] in [1, [2], 3]
print(z) # true
```
- len() 메소드로 몇 개으  데이터가 있는지 확인이 가능하다.
- 여러 데이터를 혼합하여 저장할 수도 있는데, 일관된 처리를 위해 데이터를 혼합해 넣는 것을 권장x
- 리스트에는 고정된 크기가 없다. 존재하지 않는것이 수행이 된다면 나중에 문제가 생길 수 있음.
- 가상의 정보가 생성이 된다던가, 정보가 꼬일 수 있기 때문에 보통은 에러가 발생이됨.
### 리스트의 항목 변경
```python
a = [1, 2, 3, 4, 5]
a[0] = 10000
print(a)
```
리스트와 달리, 문자열은 불변(immutable)임. 따라서 문자열의 특정 문자를 변경하는 것은 불가능함.
```python
s = 'licat'
print(s[0])
s[0] = 'k'# 출력 TypeError: 'str' object does not support item assignment
```
## 다차원 리스트
```python
b = [[10, 20, 30], [1, 2, 3]]
print(b[1][2]) # 출력: 3


rows = 3
cols = 4
#원하는 크기로 다차원 리스트 초기화
matrix = [[0 for _ in range(cols)] for _ in range(rows)] # 값 설정 
matrix[1][2]= 7
print(matrix) # 출력 [[0, 0, 0, 0], [0, 0, 7, 0], [0, 0, 0, 0]]
```
## 덧셈과 곱셈 연산
```python
import numpy as np

a = [1, 2, 3, 4, 5]
b = [6, 7, 8]

print(a + b) # 출력: [1, 2, 3, 4, 5, 6, 7, 8]


l = [1, 2, 3]
l = np.array(l)
l * 3
l + l
# 너무 당연하게 요소를 붙이는 것이다라고 생각하지 않으셨으면 좋겠습니다.
```

## 리스트 인덱싱
- 0부터 시작하고, 제일 끝의 인덱스는 -1이다. -2면 끝에서 두 번째 인덱스.
## 리스트 슬라이싱
- `[start:stop:step]` 형태로 사용됨. 디폴트 값은 `[0,인덱스 끝,1]`
- start 인덱스부터 stop-1 인덱스까지 슬라이싱 해준다.
- step이 음수면 끝 인덱스부터 시작해 역방향으로 리턴해준다.
- 슬라이싱은 에러가 발생하지 않는다.
# 리스트의 구조 및 특징
- 리스트는 연속된 메모리 공간에 원소들을 저장 x
- 각 원소들은 참조를 통해 다양한 위치에 저장된 객체를 가리킴.
- 리스트의 메모리 구조를 이해하려면 파이썬의 객체 저장 방식을 이해해야.
```python
my_list = [1, 2, 'apple', 3.14]
```
- 이 리스트의 메모리구조는 이렇게 생겼다.
![[Pasted image 20240718095018.png]]
- 파이썬에서 각 객체의 주소들은 일반적으로 연속적이지 않음.
- 다만 여기서 기억해야 할 점은, **각 객체의 주소들이 메모리상 연속적으로 존재함.**
- 연속 형태에 비해서 데이터의 추가 및 삭제가 비교적 효율적임.
- 근데 참조를 저장하기 위한 추가적인 메모리가 필요하고, 데이터가 연속적인 메모리 공간에 저장되지 않아 캐시의 지역성이 떨어짐.
- 파이썬 리스트의 메모리구조는 다양한 데이터타입과 동적인 크기 변형을 위해 메모리 및 성능 효율을 포기한 구조임.
## 동적 배열
- 파이썬의 리스트는 내부적으로 동적 배열로 구현돼 있음.
- 리스트가 공간을 초과한 데이터를 저장해야 할 경우, 자동으로 더 큰 메모리공간을 확보 -> 기존 데이터를 복사하는 방식으로 동작함.
### 접근 시간
- 인덱스를 통한 접근은 O(1)임
- 슬라이싱은 해당 범위 요소를 새 리스트로 복사하는 시간이 필요함. 시간 복잡도는 O(슬라이스의 길이)임.
- 특정 요소를 찾는 시간 복잡도는 O(n)이다.
- 마지막 요소 접근도 O(1)이다.

# 리스트 메서드
```python
print(dir(list))

# 출력
['__add__', '__class__', '__class_getitem__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
```

- `append()` : 리스트의 끝에 값을 추가 값 하나로써 리스트에 추가되니 2개의 리스트를 합치진 못함
- `insert(위치, 값)`: 주어진 위치에 값 삽입.
	
- `clear()` : 모든 항목 삭제
- `pop(위치)` 리스트의 특정 위치에 있는 값을 반환하고 해당 값을 리스트에서 삭제
	- 값이 없는 경우 마지막 값을 삭제한다.
- `remove(값)` 리스트에서 첫 번째로 발견되는 주어진 값을 삭제함.
	
- `reverse()` 리스트의 항목들의 순서를 뒤집음. 원래의 리스트를 변경하고 아무것도 반환하지 x
- `reversed()` 역순으로 새로운 이터러블 객체를 반환. 원본은 남아있는다.
	
- `sort(람다)`: 해당 리스트 자체를 정렬, 람다함수를 넣어 정렬기준 변경 가능
- `sorted(람다)` 원본은 놔두고 새로운 정렬된 리스트를 리턴, 람다함수로 정렬기준 변경 가능.
	
- `copy()` : 리스트의 얕은 복사 생성. 
- `import copy` 후 `copy .deepcopy(리스트)`하면 확실하게 깊은 복사 가능
	
- `count(값)` : 특정 값이 리스트에 몇 번 포함돼있는지 카운트하는 함수
- `extend()` 리스트에 다른 리스트나 순회 가능한 항목들을 추가함.
- `index()` 주어진 값을 찾아 해당 값의 위치(인덱스)를 반환함. 한 개밖에 반환을 안하네.