# Parallel Routes

Parallel Routes allows you to simultaneously or conditionally render one or more pages within the same layout. They are useful for highly dynamic sections of an app, such as dashboards and feeds on social sites.

For example, considering a dashboard, you can use parallel routes to simultaneously render the `team` and `analytics` pages:

![Parallel Routes Diagram](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fparallel-routes.png&w=3840&q=75&dpl=dpl_8JphtP8iYfuBbbWWAowweDQ6maYN)

## [Slots](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#slots)

Parallel routes are created using named **slots**. Slots are defined with the `@folder` convention. For example, the following file structure defines two slots: `@analytics` and `@team`:

![Parallel Routes File-system Structure](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fparallel-routes-file-system.png&w=3840&q=75&dpl=dpl_8JphtP8iYfuBbbWWAowweDQ6maYN)

Slots are passed as props to the shared parent layout. For the example above, the component in `app/layout.js` now accepts the `@analytics` and `@team` slots props, and can render them in parallel alongside the `children` prop:

app/layout.tsx

TypeScript

```
export default function Layout(props: {  children: React.ReactNode  analytics: React.ReactNode  team: React.ReactNode}) {  return (    <>      {props.children}      {props.team}      {props.analytics}    </>  )}
```

However, slots are **not** [route segments](https://nextjs.org/docs/app/building-your-application/routing#route-segments) and do not affect the URL structure. For example, for `/dashboard/@analytics/views`, the URL will be `/dashboard/views` since `@analytics` is a slot.

> **Good to know**:
> 
> - The `children` prop is an implicit slot that does not need to be mapped to a folder. This means `app/page.js` is equivalent to `app/@children/page.js`.

## [Active state and navigation](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#active-state-and-navigation)

By default, Next.js keeps track of the active _state_ (or subpage) for each slot. However, the content rendered within a slot will depend on the type of navigation:

- [**Soft Navigation**](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#5-soft-navigation): During client-side navigation, Next.js will perform a [partial render](https://nextjs.org/docs/app/building-your-application/routing/linking-and-navigating#4-partial-rendering), changing the subpage within the slot, while maintaining the other slot's active subpages, even if they don't match the current URL.
- **Hard Navigation**: After a full-page load (browser refresh), Next.js cannot determine the active state of slots that don't match the current URL. Instead, it will render a [`default.js`](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs) file for the unmatched slots, or `404` if `default.js` doesn't exist.

> **Good to know**:
> 
> - The `404` for unmatched routes helps ensure that you don't accidentally render a route that shouldn't be parallel rendered.

### [`default.js`](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs)

You can define a `default.js` file to render as a fallback for unmatched slots during the initial load or full-page reload.

Consider the following folder structure. The `@team` slot has a `settings` page, but `@analytics` does not.

![Parallel Routes unmatched routes](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fparallel-routes-unmatched-routes.png&w=3840&q=75&dpl=dpl_8JphtP8iYfuBbbWWAowweDQ6maYN)

When navigating to `/dashboard/settings`, the `@team` slot will render the `settings` page while maintaining the currently active page for the `@analytics` slot.

On refresh, Next.js will render a `default.js` for `@analytics`. If `default.js` doesn't exist, a `404` is rendered instead.

Additionally, since `children` is an implicit slot, you also need to create a `default.js` file to render a fallback for `children` when Next.js cannot recover the active state of the parent page.

### [`useSelectedLayoutSegment(s)`](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#useselectedlayoutsegments)

Both [`useSelectedLayoutSegment`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segment) and [`useSelectedLayoutSegments`](https://nextjs.org/docs/app/api-reference/functions/use-selected-layout-segments) accept a `parallelRoutesKey` parameter, which allows you to read the active route segment within a slot.

app/layout.tsx

TypeScript

```
'use client' import { useSelectedLayoutSegment } from 'next/navigation' export default function Layout(props: {  //...  auth: React.ReactNode}) {  const loginSegments = useSelectedLayoutSegment('auth')  // ...}
```

When a user navigates to `app/@auth/login` (or `/login` in the URL bar), `loginSegments` will be equal to the string `"login"`.

## [Examples](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#examples)

### [Modals](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#modals)

Parallel Routing can be used to render modals.

![Parallel Routes Diagram](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fparallel-routes-auth-modal.png&w=3840&q=75&dpl=dpl_8JphtP8iYfuBbbWWAowweDQ6maYN)

The `@auth` slot renders a `<Modal>` component that can be shown by navigating to a matching route, for example `/login`.

app/layout.tsx

TypeScript

```
export default async function Layout(props: {  // ...  auth: React.ReactNode}) {  return (    <>      {/* ... */}      {props.auth}    </>  )}
```

app/@auth/login/page.tsx

TypeScript

```
import { Modal } from 'components/modal' export default function Login() {  return (    <Modal>      <h1>Login</h1>      {/* ... */}    </Modal>  )}
```

To ensure that the contents of the modal don't get rendered when it's not active, you can create a `default.js` file that returns `null`.

app/@auth/default.tsx

TypeScript

```
export default function Default() {  return null}
```

#### [Dismissing a modal](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#dismissing-a-modal)

If a modal was initiated through client navigation, e.g. by using `<Link href="/login">`, you can dismiss the modal by calling `router.back()` or by using a `Link` component.

app/@auth/login/page.tsx

TypeScript

```
'use client'import { useRouter } from 'next/navigation'import { Modal } from 'components/modal' export default function Login() {  const router = useRouter()  return (    <Modal>      <span onClick={() => router.back()}>Close modal</span>      <h1>Login</h1>      ...    </Modal>  )}
```

> More information on modals is covered in the [Intercepting Routes](https://nextjs.org/docs/app/building-your-application/routing/intercepting-routes) section.

If you want to navigate elsewhere and dismiss a modal, you can also use a catch-all route.

![Parallel Routes Diagram](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fparallel-routes-catchall.png&w=3840&q=75&dpl=dpl_8JphtP8iYfuBbbWWAowweDQ6maYN)

app/@auth/[...catchAll]/page.tsx

TypeScript

```
export default function CatchAll() {  return null}
```

> Catch-all routes take precedence over `default.js`.

### [Conditional Routes](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#conditional-routes)

Parallel Routes also allows you to conditionally render a slot based on certain conditions, such as authentication state. For example, you can render a `/dashboard` or `/login` page depending on whether the user is logged in:

![Conditional routes diagram](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fconditional-routes-ui.png&w=3840&q=75&dpl=dpl_8JphtP8iYfuBbbWWAowweDQ6maYN)

Parallel Routes can be used to implement conditional routing. For example, you can render a `@dashboard` or `@login` route depending on the authentication state.

app/layout.tsx

TypeScript

```
import { getUser } from '@/lib/auth' export default function Layout({  dashboard,  login,}: {  dashboard: React.ReactNode  login: React.ReactNode}) {  const isLoggedIn = getUser()  return isLoggedIn ? dashboard : login}
```

![Parallel routes authentication example](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fconditional-routes-ui.png&w=3840&q=75&dpl=dpl_8JphtP8iYfuBbbWWAowweDQ6maYN)

### [Streaming](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#streaming)

Parallel Routes can be streamed independently, allowing you to define independent error and loading states for each route:

![Parallel routes enable custom error and loading states](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fparallel-routes-cinematic-universe.png&w=3840&q=75&dpl=dpl_8JphtP8iYfuBbbWWAowweDQ6maYN)