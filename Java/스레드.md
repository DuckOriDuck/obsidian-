# 운영체제의 기본적인 요소들과 그 역할
## 커널
- 운영체제의 핵심 부분으로 하드웨어와 소프트웨어 간의 인터페이스 역할을 함.
- 메모리, 프로세스, 파일 시스템, I/O등을 관리한다 .
- 시스템 자원을 관리하고 프로세스와 사용자간의 요청을 처리. 모든 시스템 작업은 커널을 통해 이루어짐
## 프로세스
- **운영체제로부터 자원을 할당받은 작업의 단위, 실행중인 프로그램의 인스턴스이다**.
- 자신의 메모리 공간을 가지고 독립적으로 실행됨. 
- 커널은 프로세스 스케줄링을 통해 CPU 시간을 배분함.
- 프로세스는 커널의 관리 하에 있으며, 다른 프로세스와 메모리를 공유 x 프로세스간에 통신이 필요할때는 IPC(inter-process communication)을 활용한다.
## 스레드
- **프로세스 내에서 실행되는 작은 실행 단위. 프로세스는 하나 이상의 스레드를 가질 수 있다.**
- 스레드는 동일한 프로세스 내에서 자원을 공유, 병렬처리를 통해 성능을 향상시킬 수 있음.
- 커널은 스레드를 스케줄링하여 실행함. 동일한 프로세스 내에서 쓰레드는 메모리를 공유하는데 다른 프로세스의 스레드와는 메모리 공유 x
## 추가적인 요소
### 메모리 관리:
- 시스템의 메모리를 효율적으로 배분하고 사용
- 커널은 각 프로세스 메모리를 할당하고 관리함. 프로세스는 자신에게 할당된 메모리 공간을 사용, 쓰레드는 이 메모리 공간을 공유함.
### 인터럽트:
- CPU의 정상 실행 흐름을 방해하고 특정 이벤트(I/O 작업, 타이머 이멘트 등 다양한 사건)가 발생했을 때 커널에서 인터럽트를 사용해서 정상 흐름을 방해하고 특정 이벤트를 처리하게 하는 메커니즘
### 스케줄링:
- CPU 시간을 프로세스나 쓰레드에게 할당하는 매커니즘
- 커널은 스케줄링 알고리즘을 사용하여 어떤 프로세스나 쓰레드를 언제 실행시킬지 결정함.
## 프로세스의 내부 구조
![[Pasted image 20240701163440.png]]
- Code: 프로그램의 소스코드(기계어 형태)
- Stack: 함수가 호출되면 stack 영역에 할당되고 종료되면 소멸한다. 함수가 사용하는 지역 변수도 함께 저장됨. -> 여기서 프로세스에서 할당된 메모리보다 stack 영역을 많이 사용하면 stackoverflow 에러 발생
- Heap: 생성자, 인스턴스와 같은 동적 할당 데이터들을 저장함.
![[Pasted image 20240701163640.png]]
- 쓰레드는 프로세스가 할당받은 자원을 이용하고, 여러개의 쓰레드가 있다면 쓰레드끼리 자원을 공유하기 때문에 동시 작업이 가능.
- 쓰레드는 stack 영역만 별도로 사용하고, code, data, ehap은 다른 쓰레드들과 공유함.
# Java에서의 쓰레드 생성.
## Thread 클래스 상속
- 쓰레드 클래스를 상속아 클래스를 정의하고 이를 이용해서 스레드 생성함,
```java
class MyThread extends Thread {
    public void run() {
        // 스레드가 수행할 작업 정의
    }
}

public class ThreadExample {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start(); // 스레드 시작
    }
}

```
## Runnable 인터페이스 구현
- Runnable 인터페이스를 구현한 클래스를 정의하고 이를 이용해서 클래스를 생성함.
```java
class MyRunnable implements Runnable {
    public void run() {
        // 스레드가 수행할 작업 정의
    }
}

public class RunnableExample {
    public static void main(String[] args) {
        Thread thread = new Thread(new MyRunnable());
        thread.start(); // 스레드 시작
    }
}

```
이 방식은 다른 클래스를 상속받아도 쓰레드를 사용할 수 있다는 것이 이점이다. 그래서 일반적으로 이 인터페이스 구현 방식을 선호함.

# 쓰레드 생성주기
![[Pasted image 20240701164203.png]]
## Runanable:
- 스레드가 싫ㅇ되기 위한 준비상태임
- CPU 점유 x 실행을 위해 대기하고 있는 상태
-  start() 메소드를 호출하면 해당 쓰레드가 runnable 상태로 진입함.
## Running
- CPU를 점유하여 실행중인 상태
- run() 메서드는 JVM에서만 호출 가능하며, 우선 순위가 높은 스레드가 결저오디면 자동으로 호출.
## Dead
- 종료 상태
- 실행중인 쓰레드가 모두 실행을 마친 후의 완료 상태
## Blocked
- 지연상태
- CPU 점유권을 상실한 상태로, 특정 메서드 실행을 통해 Runnable 상태로 전환
- wait() 메소드로 Blocked 상태가 된 스레드는 notify() 메소드 호출 시 Runnable 상태로 전환
- sleep(시간) 메소드로 Blocked 상태가 된 쓰레드는 지정된 시간이 지나면 Runnable 상태로 전환됨.
- 